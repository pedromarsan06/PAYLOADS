#!/usr/bin/env bash
# run_enum_minimal.sh
# Execução mínima/silenciosa das ferramentas clonadas em ~/tools
# NÃO usa sudo. NÃO baixa nem executa exploits.
set -euo pipefail

TOOLS_DIR="${HOME}/tools"
TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
OUTDIR="${HOME}/privesc_reports_${TIMESTAMP}"
PARSED="${OUTDIR}/parsed"
mkdir -p "$PARSED"

# Paths esperados
PEASS_DIR="${TOOLS_DIR}/PEASS-ng"
LINENUM_DIR="${TOOLS_DIR}/LinEnum"
LES2_DIR="${TOOLS_DIR}/linux-exploit-suggester-2"

LPATH="$PEASS_DIR/linPEAS/linpeas.sh"
LENUM_PATH="$LINENUM_DIR/LinEnum.sh"
LES2_SCRIPT="$LES2_DIR/linux-exploit-suggester-2.pl"

# Minimal output flag
# Very little prints: only final summary and errors.
quiet_echo() { :; }  # no-op for internal messages if you want silence
# Use "echo" only for final minimal summary

# Make scripts executable if present
[ -f "$LPATH" ] && chmod +x "$LPATH" || true
[ -f "$LENUM_PATH" ] && chmod +x "$LENUM_PATH" || true

# 1) Run linPEAS (silently -> file)
if [ -f "$LPATH" ]; then
  bash "$LPATH" > "$OUTDIR/linpeas_full.txt" 2> "$OUTDIR/linpeas_stderr.log" || true
else
  echo "ERROR: linPEAS not found in $LPATH" > "$OUTDIR/linpeas_error.txt"
fi

# 2) Run LinEnum (silently -> file)
if [ -f "$LENUM_PATH" ]; then
  bash "$LENUM_PATH" > "$OUTDIR/linenum_full.txt" 2> "$OUTDIR/linenum_stderr.log" || true
else
  echo "ERROR: LinEnum not found in $LENUM_PATH" > "$OUTDIR/linenum_error.txt"
fi

# 3) Kernel/distro info
KERNEL="$(uname -r 2>/dev/null || echo unknown)"
OSPRETTY="$(grep -E '^PRETTY_NAME=' /etc/os-release 2>/dev/null | cut -d= -f2- | tr -d '"' || echo unknown)"
printf "kernel: %s\n" "$KERNEL" > "$OUTDIR/kernel_info.txt"
printf "distro: %s\n" "$OSPRETTY" >> "$OUTDIR/kernel_info.txt"

# 4) Run LES2 (suggestions only)
if [ -f "$LES2_SCRIPT" ]; then
  perl "$LES2_SCRIPT" -k "$KERNEL" > "$OUTDIR/les2_full.txt" 2> "$OUTDIR/les2_stderr.log" || true
else
  echo "LES2_not_found" > "$OUTDIR/les2_full.txt"
fi

# 5) Collect local lists (no sudo). May show permission denied in many paths.
(find / -perm -4000 -type f -print 2>/dev/null || true) > "$OUTDIR/suid_list.txt"
(find / -perm -2000 -type f -print 2>/dev/null || true) > "$OUTDIR/sgid_list.txt"
(find / -xdev -type f -perm -o+w -print 2>/dev/null || true) > "$OUTDIR/world_writable_files.txt"
(find / -xdev -type d -perm -o+w -print 2>/dev/null || true) > "$OUTDIR/world_writable_dirs.txt"

(ls -la /etc/cron* /var/spool/cron /var/spool/cron/crontabs 2>/dev/null || true) > "$OUTDIR/cron_locations.txt"
crontab -l 2>/dev/null > "$OUTDIR/my_crontab.txt" || true
cat "$HOME/.bash_history" 2>/dev/null > "$OUTDIR/bash_history.txt" || true
egrep -i "id_rsa|PRIVATE KEY|password|passwd|ssh-rsa" -R --binary-files=without-match "$HOME" 2>/dev/null > "$OUTDIR/sus_strings.txt" || true

# 6) Simple parsing helpers - extract tokens/filenames for matching
# Extract basenames of SUIDs/SGIDs to compare with LES2 suggestions
awk -F/ '{print $NF}' "$OUTDIR/suid_list.txt" | sed '/^$/d' | tr '[:upper:]' '[:lower:]' | sort -u > "$PARSED/suid_names.txt" || true
awk -F/ '{print $NF}' "$OUTDIR/sgid_list.txt" | sed '/^$/d' | tr '[:upper:]' '[:lower:]' | sort -u > "$PARSED/sgid_names.txt" || true

# Extract words from writable dirs (last path component)
awk -F/ '{print $NF}' "$OUTDIR/world_writable_dirs.txt" | sed '/^$/d' | tr '[:upper:]' '[:lower:]' | sort -u > "$PARSED/writable_dir_names.txt" || true

# Extract sudo-ish mentions from linpeas/linenum outputs (no sudo -l to avoid password prompt)
grep -iE "sudo|NOPASSWD|sudo -l|sudoers" "$OUTDIR/linpeas_full.txt" 2>/dev/null | sed 's/^[[:space:]]*//' | sed '/^$/d' > "$PARSED/sudo_mentions.txt" || true
grep -iE "sudo|NOPASSWD|sudo -l|sudoers" "$OUTDIR/linenum_full.txt" 2>/dev/null | sed 's/^[[:space:]]*//' | sed '/^$/d' >> "$PARSED/sudo_mentions.txt" || true
sort -u "$PARSED/sudo_mentions.txt" -o "$PARSED/sudo_mentions.txt" || true

# 7) Parse LES2 suggestions into lines (lowercase) for matching
tr '[:upper:]' '[:lower:]' < "$OUTDIR/les2_full.txt" | sed '/^$/d' > "$PARSED/les2_lower.txt" || true

# 8) Matching logic (very conservative):
# - If LES2 mentions a basename that equals a SUID/SGID basename => possible match.
# - If LES2 mentions 'cron' or 'crontab' and we have cron files => match.
# - If LES2 mentions kernel or the exact kernel string => match.
# - If LES2 mentions writable dir names present in writable dirs => match.
MATCHED="$OUTDIR/matched_les2_local.txt"
> "$MATCHED"

# match SUID/SGID basenames
while read -r bin; do
  [ -z "$bin" ] && continue
  # grep whole-word in les2 suggestions
  if grep -qw -- "$bin" "$PARSED/les2_lower.txt" 2>/dev/null; then
    echo "MATCH: SUID/SGID binary '$bin' mentioned in LES2 suggestions" >> "$MATCHED"
  fi
done < "$PARSED/suid_names.txt"

while read -r bin; do
  [ -z "$bin" ] && continue
  if grep -qw -- "$bin" "$PARSED/les2_lower.txt" 2>/dev/null; then
    echo "MATCH: SGID binary '$bin' mentioned in LES2 suggestions" >> "$MATCHED"
  fi
done < "$PARSED/sgid_names.txt"

# match writable dir names
while read -r dname; do
  [ -z "$dname" ] && continue
  if grep -qw -- "$dname" "$PARSED/les2_lower.txt" 2>/dev/null; then
    echo "MATCH: writable dir name '$dname' mentioned in LES2 suggestions" >> "$MATCHED"
  fi
done < "$PARSED/writable_dir_names.txt"

# match cron presence
if [ -s "$OUTDIR/cron_locations.txt" ] || [ -s "$OUTDIR/my_crontab.txt" ]; then
  if grep -qi "cron" "$PARSED/les2_lower.txt" 2>/dev/null; then
    echo "MATCH: LES2 mentions 'cron' and cron files found on system" >> "$MATCHED"
  fi
fi

# match kernel exact or partial
if [ -n "$KERNEL" ] && [ "$KERNEL" != "unknown" ]; then
  if grep -Fqi "$KERNEL" "$PARSED/les2_lower.txt" 2>/dev/null; then
    echo "MATCH: LES2 suggestions mention the exact kernel string: $KERNEL" >> "$MATCHED"
  else
    # try partial kernel major.minor match
    KPART="$(echo "$KERNEL" | awk -F. '{print $1"."$2}')"
    if grep -Fqi "$KPART" "$PARSED/les2_lower.txt" 2>/dev/null; then
      echo "MATCH: LES2 suggestions mention kernel family: $KPART (system kernel: $KERNEL)" >> "$MATCHED"
    fi
  fi
fi

# dedupe matched
sort -u "$MATCHED" -o "$MATCHED" || true

# 9) Aggregate everything into a single detailed file
DETAILED="$OUTDIR/detailed_all_findings.txt"
{
  printf "Relatório gerado: %s\n\n" "$(date -u)"
  printf "Kernel: %s\nDistro: %s\n\n" "$KERNEL" "$OSPRETTY"

  printf "== LinPEAS (arquivo): %s ==\n\n" "$OUTDIR/linpeas_full.txt"
  sed -n '1,200p' "$OUTDIR/linpeas_full.txt" 2>/dev/null || true
  printf "\n\n== LinEnum (arquivo): %s ==\n\n" "$OUTDIR/linenum_full.txt"
  sed -n '1,200p' "$OUTDIR/linenum_full.txt" 2>/dev/null || true

  printf "\n\n== SUID aggregated (sample) ==\n"
  sed -n '1,200p' "$PARSED/suid_names.txt" 2>/dev/null || true

  printf "\n\n== World-writable dirs sample ==\n"
  sed -n '1,200p' "$PARSED/writable_dir_names.txt" 2>/dev/null || true

  printf "\n\n== LES2 suggestions (sample) ==\n"
  sed -n '1,200p' "$PARSED/les2_lower.txt" 2>/dev/null || true

  printf "\n\n== Matched LES2 <-> local ==\n"
  sed -n '1,200p' "$MATCHED" 2>/dev/null || true

  printf "\n\n== Arquivos gerados e parseados estão em: %s ==\n" "$PARSED"
} > "$DETAILED"

# 10) Minimal summary counts (printed)
count_lines() {
  local f="$1"
  if [ -f "$f" ]; then
    wc -l < "$f" 2>/dev/null | xargs
  else
    echo 0
  fi
}

SUID_C=$(count_lines "$PARSED/suid_names.txt")
SGID_C=$(count_lines "$OUTDIR/sgid_list.txt")
SUDO_C=$(count_lines "$PARSED/sudo_mentions.txt")
CRON_C=$(count_lines "$OUTDIR/cron_locations.txt")
WRITABLE_C=$(count_lines "$PARSED/writable_dir_names.txt")
SUS_C=$(count_lines "$OUTDIR/sus_strings.txt")
LES2_C=$(count_lines "$PARSED/les2_lower.txt")
MATCH_C=$(count_lines "$MATCHED")

echo ""
echo "===== Resumo (apenas números) ====="
echo "SUID (basenames): $SUID_C"
echo "SGID (raw lines): $SGID_C"
echo "Sudo-mentions (linpeas/linenum): $SUDO_C"
echo "Cron files (raw): $CRON_C"
echo "Writable dir names: $WRITABLE_C"
echo "Sus strings (home): $SUS_C"
echo "LES2 suggestion lines: $LES2_C"
echo "Possíveis matches LES2/local: $MATCH_C"
echo ""
echo "Relatório completo: $DETAILED"
echo "Matched details: $MATCHED"
echo ""

# End
exit 0
